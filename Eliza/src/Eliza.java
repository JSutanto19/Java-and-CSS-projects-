//////////////////// ALL ASSIGNMENTS INCLUDE THIS SECTION /////////////////////
//
// Title: Sokoban
// Files: TestSokoban.Java, Config.Java
// Course: CS 200 Fall 2018
//
// Author: Jason Sutanto
// Email: jsutanto2@wisc.edu email address
// Lecturer's Name: Marc Renault
//
///////////////////////////// CREDIT OUTSIDE HELP /////////////////////////////
//
// Students who get help from sources other than their partner must fully
// acknowledge and credit those sources of help here. Instructors and TAs do
// not need to be credited here, but tutors, friends, relatives, room mates
// strangers, etc do. If you received no outside help from either type of
// source, then please explicitly indicate NONE.
//
// Persons: NONE
// Online Sources: NONE
//
/////////////////////////////// 80 COLUMNS WIDE ///////////////////////////////
import java.util.ArrayList;
import java.util.Arrays;
import java.io.File;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.FileReader;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Random;
import java.util.Scanner;
import java.io.FileOutputStream;

/**
 * The Eliza class holds the user input and response formation for a system that collects user input
 * and responds appropriately. Eliza is based off of a computer program written at MIT in the 1960's
 * by Joseph Weizenbaum. Eliza uses keyword matching to respond to users in a way that displays
 * interest in the users and continues the conversation until instructed otherwise.
 */
public class Eliza {

    /*
     * This method does input and output with the user. It calls supporting methods to read and
     * write files and process each user input.
     * 
     * @param args (unused)
     */
    public static void main(String[] args) {
        // Milestone 2
        // create a scanner for reading user input and a random number
        // generator with Config.SEED as the seed
        Scanner scnr = new Scanner(System.in);// scanner used to save user input
        Random rand = new Random(Config.SEED);// random number generator used to generate a random
                                              // selected response
        String name = "";// stores reference of user's name
        String therapist = "";// stores reference of therapist name
        String userInput = "";// stores the reference of user's input
        String[] words;// array of strings from userInput split by spaces
        boolean quitWords = false;// variable used to test if userInput contains quit word
        boolean error = false;// variable used to test if dialog cannot be save to a file
        String programResponse = "";// the response generated by the program
        String saveChoice = "";// saves choice if user wants to save conversation
        String fileName = "";// the name of the file user wants to save conversation in
        ArrayList<String> dialog = new ArrayList<String>();// arrayList that stores conversation
        ArrayList<ArrayList<String>> responseTable = new ArrayList<ArrayList<String>>();// arrayList
                                                                                        // of
                                                                                        // arrayList
                                                                                        // that
                                                                                        // stores
                                                                                        // keywords
                                                                                        // and
                                                                                        // responses
                                                                                        // depending
                                                                                        // on
                                                                                        // therapist
                                                                                        // name
        if (args.length > 1) { // checks if args array has more than one element then asks user to
                               // choose between elements. The element chosen by user becomes the
                               // therapist's name and loads the responseTable with the name of
                               // therapist concatenated with Confif.file extension.
            System.out.print("Would you like to speak with ");
            for (int i = 0; i < args.length; ++i) {

                if (i < args.length - 1) {
                    System.out.print(args[i] + ", "); // prints elements in args
                } else {
                    System.out.print(args[i] + "?");
                }
            }
            therapist = scnr.nextLine();
            responseTable = loadResponseTable(therapist + Config.RESPONSE_FILE_EXTENSION);

        } else if (args.length == 1) { // if args only contains one element than therapist name is
                                       // set to the element and load responseTable with the
                                       // therapist's name + Config.RESPONSE_FILE_EXTENSION
            therapist = args[0];
            responseTable = Eliza.loadResponseTable(therapist + Config.RESPONSE_FILE_EXTENSION);
        } else {// if args does not contain any elements set therapist's name to Eliza and load
                // responseTable with therapist name + Config.RESPONSE_FILE_EXTENSION
            therapist = "Eliza";
            responseTable = loadResponseTable("Eliza" + Config.RESPONSE_FILE_EXTENSION);
        }

        // Milestone 2
        // name prompt
        System.out.println("Hi my name is " + therapist + ". What is your name");// prompts for
                                                                                 // user's name
        name = scnr.nextLine();
        dialog.add("Hi my name is " + therapist + ". What is your name");
        dialog.add(name);


        System.out.println("Nice to meet you " + name + ". What is on your mind"); // welcome prompt

        // Milestone 2
        // begin conversation loop
        do {


            // Milestone 2
            // obtain user input
            userInput = scnr.nextLine();
            dialog.add("Nice to meet you " + name + ". What is on your mind");
            dialog.add(userInput);
            // Milestone 2
            // prepareInput
            // userInput = scnr.nextLine();
            words = Eliza.prepareInput(userInput);

            if (words == null) {// checks if words is null and if true set quitWords to true. This
                                // means there is a quit word in userInput
                quitWords = true;
            }


            if (!quitWords) {// if no quit word is in userInput print program response with
                             // prepareResponse method
                programResponse = Eliza.prepareResponse(words, rand, responseTable);
                dialog.add(programResponse);
                System.out.println(programResponse);
            }
            // Milestone 2
            // end loop if quit word is found
        } while (!quitWords);

        // Milestone 2
        // ending prompt
        System.out.println("Goodbye " + name);
        dialog.add("Goodbye " + name);// add ending prompt to dialog arrayList
        System.out.print("Would you like to have a record of our conversation (y/n): "); // prompts
                                                                                         // user to
                                                                                         // save
                                                                                         // file
        saveChoice = scnr.nextLine();
        while (!error) {
            try {
                if (saveChoice.charAt(0) == 'y' || saveChoice.charAt(0) == 'Y') {// if user answers
                                                                                 // yes. prompt user
                                                                                 // to enter file
                                                                                 // name and save
                                                                                 // dialog to file
                                                                                 // then print thank
                                                                                 // you prompt
                    System.out.print("Enter fileName: ");
                    fileName = scnr.nextLine();
                    saveDialog(dialog, fileName);
                    System.out.println("Thanks again for talking! Our conversation is saved in: "
                        + fileName + ".");
                    error = true;
                } else {
                    error = true;// if user says no end loop
                }
            } catch (IOException e) {
                System.out.println("Unable to save conversation to: " + fileName);// print error
                                                                                  // statement if
                                                                                  // error
                                                                                  // IOException is
                                                                                  // caught
            }
        }
    }

    /**
     * This method processes the user input, returning an ArrayList containing Strings, where each
     * String is a phrase from the user's input. This is done by removing leading and trailing
     * whitespace, making the user's input all lower case, then going through each character of the
     * user's input. When going through each character this keeps all digits, alphabetic characters
     * and ' (single quote). The characters ? ! , . signal the end of a phrase, and possibly the
     * beginning of the next phrase, but are not included in the result. All other characters such
     * as ( ) - " ] etc. should be replaced with a space. This method makes sure that every phrase
     * has some visible characters but no leading or trailing whitespace and only a single space
     * between words of a phrase. If userInput is null then return null, if no characters then
     * return a 0 length list, otherwise return a list of phrases. Empty phrases and phrases with
     * just invalid/whitespace characters should NOT be added to the list.
     * 
     * Example userInput: "Hi, I am! a big-fun robot!!!" Example returned: "hi", "i am", "a big fun
     * robot"
     * 
     * @param userInput text the user typed
     * @return the phrases from the user's input
     */

    public static ArrayList<String> separatePhrases(String userInput) {
        ArrayList<String> separatePhrases = new ArrayList<String>();// ArrayList that contains
                                                                    // userInput separated into
                                                                    // phrases
        userInput = userInput.trim().toLowerCase();// make string lowercase
        if (userInput == null) {// checks if userInput is null and returns null
            return null;
        } else if (userInput.length() == 0) {// checks if userInput contains 0 elements. if true
                                             // return arrayList
            return separatePhrases;
        } else {
            String newStr = "";// stores reference of new string which is concatenated from
                               // userInput characters at index i
            for (int i = 0; i < userInput.length(); ++i) {
                if (Character.isDigit(userInput.charAt(i))// checks if character in userInput at
                                                          // index i is an alphabet, apostrophe or
                                                          // number. if true add character to newStr
                    || Character.isAlphabetic(userInput.charAt(i)) || userInput.charAt(i) == '\'') {//
                    newStr += userInput.charAt(i);
                } else if (userInput.charAt(i) == '.' || userInput.charAt(i) == ','// checks if
                                                                                   // character in
                                                                                   // userInput at
                                                                                   // index i is a
                                                                                   // punctuation
                                                                                   // mark. If true
                                                                                   // check if
                                                                                   // newStr is
                                                                                   // empty and then
                                                                                   // add newStr to
                                                                                   // arrayList and
                                                                                   // set newStr to
                                                                                   // ""
                    || userInput.charAt(i) == '?' || userInput.charAt(i) == '!') {
                    newStr = newStr.trim().toLowerCase();
                    if (!newStr.isEmpty()) {
                        separatePhrases.add(newStr);
                        newStr = "";
                    }
                }

                else {
                    if (newStr.length() != 0 && newStr.charAt(newStr.length() - 1) != ' ') {// checks
                                                                                            // number
                                                                                            // of
                                                                                            // characters
                                                                                            // in
                                                                                            // newStr
                                                                                            // is
                                                                                            // greater
                                                                                            // than
                                                                                            // 0 and
                                                                                            // checks
                                                                                            // if
                                                                                            // current
                                                                                            // character
                                                                                            // is a
                                                                                            // space.
                                                                                            // If
                                                                                            // true
                                                                                            // add a
                                                                                            // space
                        newStr += ' ';
                    }
                }
            }
            newStr = newStr.trim().toLowerCase();
            if (!newStr.isEmpty()) { // continue adding characters to newStr that is not invalid an
                                     // invalid character, number or alphabet
                separatePhrases.add(newStr);
                newStr = "";
            }
            return separatePhrases;

        }
    }

    /**
     * Checks whether any of the phrases in the parameter match a quit word from Config.QUIT_WORDS.
     * Note: complete phrases are matched, not individual words within a phrase.
     * 
     * @param phrases List of user phrases
     * @return true if any phrase matches a quit word, otherwise false
     */
    public static boolean foundQuitWord(ArrayList<String> phrases) {
        String[] quitWords = Config.QUIT_WORDS;// store reference of quit words array in Config
        for (int i = 0; i < phrases.size(); ++i) {
            for (int j = 0; j < quitWords.length; ++j) {
                if (phrases.get(i).equals(quitWords[j])) {// check if elements in arrayList is a
                                                          // quit words. If true return true
                    return true;
                }
            }
        }

        return false; // if phrases does not contain a quit word return false
    }

    /**
     * Iterates through the phrases of the user's input, finding the longest phrase to which to
     * respond. If two phrases are the same length, returns whichever has the lower index in the
     * list. If phrases parameter is null or size 0 then return "" (Update 11/15/18).
     * 
     * @param phrases List of user phrases
     * @return the selected phrase
     */
    public static String selectPhrase(ArrayList<String> phrases) {
        ArrayList<String> str = new ArrayList<String>();
        if (phrases == null || phrases.size() == 0) { // checks if phrase is false and if number of
                                                      // elements in phrasese is 0. If true return
                                                      // null.
            return "";
        }
        String largestPhrase = phrases.get(0);// variable stores reference of largest phrase in
                                              // arraylist
        for (int i = 1; i < phrases.size(); ++i) {
            if (largestPhrase.length() < phrases.get(i).length()) {// checks if an element in
                                                                   // arrayList contains more
                                                                   // characters than largest phrase
                                                                   // variable. If true store
                                                                   // reference of element with more
                                                                   // chracters
                largestPhrase = phrases.get(i);
            }

            else if (largestPhrase.length() == phrases.get(i).length()) {// if two elements in
                                                                         // arrayList have the same
                                                                         // number of characters
                                                                         // return the character
                                                                         // with the earlier index
                                                                         // in arrayList.
                if (phrases.indexOf(largestPhrase) > phrases.indexOf(phrases.get(i))) {
                    largestPhrase = phrases.get(i);
                }

            }

        }

        return largestPhrase;
    }

    /**
     * Looks for a replacement word for the word parameter and if found, returns the replacement
     * word. Otherwise if the word parameter is not found then the word parameter itself is
     * returned. The wordMap parameter contains rows of match and replacement strings. On a row, the
     * element at the 0 index is the word to match and if it matches return the string at index 1 in
     * the same row. Some example word maps that will be passed in are Config.INPUT_WORD_MAP and
     * Config.PRONOUN_MAP.
     * 
     * If word is null return null. If wordMap is null or wordMap length is 0 simply return word
     * parameter. For this implementation it is reasonable to assume that if wordMap length is >= 1
     * then the number of elements in each row is at least 2.
     * 
     * @param word The word to look for in the map
     * @param wordMap The map of words to look in
     * @return the replacement string if the word parameter is found in the wordMap otherwise the
     *         word parameter itself.
     */
    public static String replaceWord(String word, String[][] wordMap) {
        String replacement = "";// stores replacement word
        if (word == null) {// checks if word is null and then return null
            return null;
        }
        if (wordMap == null || wordMap.length == 0) {// checks if wordMap is null and has length off
                                                     // 0. If true return word
            return word;
        }

        for (int i = 0; i < wordMap.length; ++i) {
            for (int j = 0; j < wordMap[i].length - 1; ++j) {
                if (word.equals(wordMap[i][0])) {// checks if word is a keywords
                    replacement = wordMap[i][wordMap[i].length - 1];// stores reference of word to
                                                                    // replace
                    return replacement;// return replacement
                }
            }
        }
        return word;// if word is not a keyword return word

    }

    /**
     * Concatenates the elements in words parameter into a string with a single space between each
     * array element. Does not change any of the strings in the words array. There are no leading or
     * trailing spaces in the returned string.
     * 
     * @param words a list of words
     * @return a string containing all the words with a space between each.
     */
    public static String assemblePhrase(String[] words) {
        String str = " ";// stores reference of concatenated string elements in words array
        for (int i = 0; i < words.length; ++i) {
            str += words[i] + " ";// adds all elements in words array to variable str
        }


        return str.trim();// return str and delete all trailing and leading whitespace
    }

    /**
     * Replaces words in phrase parameter if matching words are found in the mapWord parameter. A
     * word at a time from phrase parameter is looked for in wordMap which may result in more than
     * one word. For example: i'm => i am Uses the replaceWord and assemblePhrase methods. Example
     * wordMaps are Config.PRONOUN_MAP and Config.INPUT_WORD_MAP. If wordMap is null then phrase
     * parameter is returned. Note: there will Not be a case where a mapping will itself be a key to
     * another entry. In other words, only one pass through swapWords will ever be necessary.
     * 
     * @param phrase The given phrase which contains words to swap
     * @param wordMap Pairs of corresponding match & replacement words
     * @return The reassembled phrase
     */
    public static String swapWords(String phrase, String[][] wordMap) {

        if (wordMap == null || phrase == null) { // checks if wordMap is null or phrase is null
            return phrase;
        }

        String[] words = phrase.split(" "); // splits phrase by spaces and assigns each separated
                                            // word to a separate array index
        for (int i = 0; i < words.length; i++) { // this loop iterates through words array
            for (int j = 0; j < wordMap.length; ++j) {
                if (words[i].equals(wordMap[j][0])) { // checks if any elements in array are equal
                                                      // to elements in first column of wordMap
                    if (replaceWord(words[i], wordMap).equals(words[i])) { // if replaceWord method
                        words[i] = words[i]; // returns an element in
                    } // words. the element at
                      // array index i of words
                      // is the same
                    else {
                        words[i] = Eliza.replaceWord(words[i], wordMap); // otherwise change the
                    } // reference of element in
                } // array index of i in
            } // words to the replaced
        } // word.
        phrase = assemblePhrase(words); // use assemblePhrase method to concatenate element in words
        return phrase; // array
    }

    /**
     * This prepares the user input. First, it separates input into phrases (using separatePhrases).
     * If a phrase is a quit word (foundQuitWord) then return null. Otherwise, select a phrase
     * (selectPhrase), swap input words (swapWords with Config.INPUT_WORD_MAP) and return an array
     * with each word its own element in the array.
     * 
     * @param input The input from the user
     * @return words from the selected phrase
     */
    public static String[] prepareInput(String input) {
        ArrayList<String> phrases = new ArrayList<String>();
        String selectedPhrase;
        phrases = separatePhrases(input);// separate input by phrases and add phrase to arrayList
        if (foundQuitWord(phrases)) { // checks if any phrases in arrayList contain Quit Words
                                      // returns null if condition is true
            return null;
        }
        selectedPhrase = selectPhrase(phrases);// finds the selected phrase in arrayList
        selectedPhrase = swapWords(selectedPhrase, Config.INPUT_WORD_MAP);// swaps words in selected
                                                                          // phrase
        return selectedPhrase.split(" ");
    }

    /**
     * Reads a file that contains keywords and responses. A line contains either a list of keywords
     * or response, any blank lines are ignored. All leading and trailing whitespace on a line is
     * ignored. A keyword line begins with "keywords" with all the following tokens on the line, the
     * keywords. Each line that follows a keyword line that is not blank is a possible response for
     * the keywords. For example (the numbers are for our description purposes here and are not in
     * the file):
     * 
     * 1 keywords computer 2 Do computers worry you? 3 Why do you mention computers? 4 5 keywords i
     * dreamed 6 Really, <3>? 7 Have you ever fantasized <3> while you were awake? 8 9 Have you ever
     * dreamed <3> before?
     *
     * In line 1 is a single keyword "computer" followed by two possible responses on lines 2 and 3.
     * Line 4 and 8 are ignored since they are blank (contain only whitespace). Line 5 begins new
     * keywords that are the words "i" and "dreamed". This keyword list is followed by three
     * possible responses on lines 6, 7 and 9.
     * 
     * The keywords and associated responses are each stored in their own ArrayList. The response
     * table is an ArrayList of the keyword and responses lists. For every keywords list there is an
     * associated response list. They are added in pairs into the list that is returned. There will
     * always be an even number of items in the returned list.
     * 
     * Note that in the event an IOException occurs when trying to read the file then an error
     * message "Error reading <fileName>", where <fileName> is the parameter, is printed and a
     * non-null reference is returned, which may or may not have any elements in it.
     * 
     * @param fileName The name of the file to read
     * @return The response table
     */
    public static ArrayList<ArrayList<String>> loadResponseTable(String fileName) {
        ArrayList<ArrayList<String>> responseTable = new ArrayList<ArrayList<String>>();
        ArrayList<String> keyword = new ArrayList<String>();
        ArrayList<String> response = new ArrayList<String>();
        String line = "";
        Scanner reader = null;
        try {
            File table = new File(fileName);
            reader = new Scanner(table);
            while (reader.hasNextLine()) {
                line = reader.nextLine().trim();
                if (line.isEmpty()) {
                    continue; // skips line if line in file is empty
                } else if (line.contains("keywords")) {
                    keyword = new ArrayList<String>();// keywords = new array
                    String[] lines = line.split(" ");// line becomes array of Strings
                    for (int i = 0; i < lines.length; ++i) {
                        if (i > 0) {
                            keyword.add(lines[i].trim()); // adds words after keywords in the line
                                                          // of a file to keyword arraylist
                        }
                    }
                    responseTable.add(keyword);// add keywords to response
                    response = new ArrayList<String>(); // removes all elements in response array
                                                        // list
                    responseTable.add(response); // adds all element in response to response table
                } else {
                    response.add(line); // adds line red from file to response array list
                }
            }
        } catch (IOException e) {
            System.out.print("Error reading " + fileName); // catches IOexception and prints this
                                                           // error message
        } finally {
            if (reader != null) {
                reader.close(); // closes scanner if scanner is not null
            }
        }
        return responseTable; // returns responseTable or master arraylist
    }

    /**
     * Checks to see if the keywords match the sentence. In other words, checks to see that all the
     * words in the keyword list are in the sentence and in the same order. If all the keywords
     * match then this method returns an array with the unmatched words before, between and after
     * the keywords. If the keywords do not match then null is returned.
     * 
     * When the phrase contains elements before, between, and after the keywords, each set of the
     * three is returned in its own element String[] keywords = {"i", "dreamed"}; String[] phrase =
     * {"do", "you", "know", that", "i", "have", "dreamed", "of", "being", "an", "astronaut"};
     * 
     * toReturn[0] = "do you know that" toReturn[1] = "have" toReturn[2] = "of being an astronaut"
     * 
     * In an example where there is a single keyword, the resulting List's first element will be the
     * the pre-sequence element and the second element will be everything after the keyword, in the
     * phrase String[] keywords = {"always"}; String[] phrase = {"I", "always", "knew"};
     * 
     * toReturn[0] = "I" toReturn[1] = "knew"
     * 
     * In an example where a keyword is not in the phrase in the correct order, null is returned.
     * String[] keywords = {"computer"}; String[] phrase = {"My","dog", "is", "lost"};
     * 
     * return null
     * 
     * @param keywords The words to match, in order, in the sentence.
     * @param phrase Each word in the sentence.
     * @return The unmatched words before, between and after the keywords or null if the keywords
     *         are not all matched in order in the phrase.
     */
    public static String[] findKeyWordsInPhrase(ArrayList<String> keywords, String[] phrase) {
        // see the algorithm presentation linked in Eliza.pdf.
        String[] unmatched = new String[keywords.size() + 1]; // array of unmatched phrases
        Arrays.fill(unmatched, ""); // makes every index in unmatched refer to empty string
        if (keywords.size() == 0) {
            unmatched[0] = assemblePhrase(phrase);
            return unmatched;
        }
        int match = 0;// counts number of keywords in phrase
        int j = 0;// counter for keywords
        int k = 0; // counter for unmatched array
        for (int i = 0; i < phrase.length; ++i) { // iterates through phrase
            if (phrase[i].equals(keywords.get(j))) { // checks if any elements in phrase have
                                                     // keywords in ArrayList
                match += 1;
                ++k;
                if (j < keywords.size() - 1) { // increments counter by one if counter is less than
                                               // size keywords ArrayList
                    ++j;
                }
            } else {
                if (unmatched[k].equals("")) { // checks if unmatched element is an empty string.
                                               // Then adds an element in phrase that is not in
                                               // keywords
                    unmatched[k] += phrase[i];
                } else {
                    unmatched[k] += " " + phrase[i];// otherwise adds element in phrase that is not
                                                    // in keywords ArrayList to unmatched array at
                                                    // index k
                }
            }
        }
        if (match != keywords.size()) { // checks if number of keywords matched is the same as the
                                        // number of keywords in keywords ArrayList. return null if
                                        // true.
            return null;
        } else { // otherwise return unmatched array
            return unmatched;
        }

    }

    /**
     * Selects a randomly generated response within the list of possible responses using the
     * provided random number generator where the number generated corresponds to the index of the
     * selected response. Use Random nextInt( responseList.size()) to generate the random number. If
     * responseList is null or 0 length then return null.
     * 
     * @param rand A random number generator.
     * @param responseList A list of responses to choose from.
     * @return A randomly selected response
     */
    public static String selectResponse(Random rand, ArrayList<String> responseList) {
        if (responseList == null || responseList.size() == 0) { // checks if responslist is null or
                                                                // contains zero elements. if true
                                                                // return null
            return null;
        }
        int responseNum = rand.nextInt(responseList.size());// random number used to get repsponse
                                                            // in responseList.
        return responseList.get(responseNum);// return randomly selected response.
    }

    /**
     * This method takes processed user input and forms a response. This looks through the response
     * table in order checking to see if each keyword pattern matches the userWords. The first
     * matching keyword pattern found determines the list of responses to choose from. A keyword
     * pattern matches the userWords, if all the keywords are found, in order, but not necessarily
     * contiguous. This keyword matching is done by findKeyWordsInPhrase method. See the
     * findKeyWordsInPhrase algorithm in the Eliza.pdf.
     * 
     * If no keyword pattern matches then Config.NO_MATCH_RESPONSE is returned. Otherwise one of
     * possible responses for the matched keywords is selected with selectResponse method. The
     * response selected is checked for the replacement symbol <n> where n is 1 to the length of
     * unmatchedWords array returned by findKeyWordsInPhrase. For each replacement symbol the
     * corresponding unmatched words element (index 0 for <1>, 1 for <2> etc.) has its pronouns
     * swapped with swapWords using Config.PRONOUN_MAP and then replaces the replacement symbol in
     * the response.
     * 
     * @param userWords using input after preparing.
     * @param rand A random number generator.
     * @param responseTable A table containing a list of keywords and response pairs.
     * @return The generated response
     */
    public static String prepareResponse(String[] userWords, Random rand,
        ArrayList<ArrayList<String>> responseTable) {

        // Iterate through the response table.
        // The response table has paired rows. The first row is a list of key
        // words, the next a list of corresponding responses. The 3rd row another
        // list of keywords and 4th row the corresponding responses.

        // checks to see if the current keywords match the user's words
        // using findKeyWordsInPhrase.

        // if no keyword pattern was matched, return Config.NO_MATCH_RESPONSE
        // else, select a response using the appropriate list of responses for the keywords

        // Look for <1>, <2> etc in the chosen response. The number starts with 1 and
        // there won't be more than the number of elements in unmatchedWords returned by
        // findKeyWordsInPhrase. Note the number of elements in unmatchedWords will be
        // 1 more than the number of keywords.
        // For each <n> found, find the corresponding unmatchedWords phrase (n-1) and swap
        // its pronoun words (swapWords using Config.PRONOUN_MAP). Then use the
        // result to replace the <n> in the chosen response.

        // in the selected echo, swap pronouns

        // inserts the new phrase with pronouns swapped, into the response
        String selectedResponse; // variable stores selected response from responseList
        String[] unmatched = null;// variable store references of unmatched array returned in
                                  // findKeyWordsInPhrase method
        int i = 0;// counter for responseTable
        for (; i < responseTable.size() - 1; i += 2) {// iterates through responsTable
            unmatched = findKeyWordsInPhrase(responseTable.get(i), userWords);
            if (unmatched != null) { // checks if any elements in words array is equal to a keyword
                                     // in responseList. if true exit loop
                break;
            }
        }
        if (unmatched == null) { // checks if no elements in userWords is a keyword in responseList.
                                 // If true return NO_MATCH_RESPONSE
            return Config.NO_MATCH_RESPONSE;
        } else {
            selectedResponse = selectResponse(rand, responseTable.get(i + 1));// if an element in
                                                                              // userWords is a
                                                                              // keyword a random
                                                                              // response is
                                                                              // selected in
                                                                              // responseList
            String replace = "";// stores reference of the string to replace in selectedResponse
            String swapWord = "";// stores reference of elements swapped in unmatched array
            for (int j = 1; j <= unmatched.length; j++) {
                replace = "<" + j + ">";
                if (selectedResponse.contains(replace)) {// checks if selectedResponse contains
                                                         // replace string instance. if true swap
                                                         // elements in unmatched array and then
                                                         // replaces the replace string with swapped
                                                         // words in unmatched
                    swapWord = swapWords(unmatched[j - 1], Config.PRONOUN_MAP);
                    selectedResponse = selectedResponse.replaceFirst(replace, swapWord);
                }
            }
            return selectedResponse;// return selectedResponse if a keyword in responseList is found
                                    // in userWords
        }
    }

    /**
     * Creates a file with the given name, and fills that file line-by-line with the tracked
     * conversation. Every line ends with a newline. Throws an IOException if a writing error
     * occurs.
     * 
     * @param dialog the complete conversation
     * @param fileName The file in which to write the conversation
     * @throws IOException
     */
    public static void saveDialog(ArrayList<String> dialog, String fileName) throws IOException {
        File file = new File(fileName);// create file named as the fileName parameter
        PrintWriter outFS = null; // create printWriter object to write onto file

        try {
            outFS = new PrintWriter(file);// try to open file
            // File is open and valid if we got this far (otherwise exception thrown)
            // write every element in dialog arraylist to file.
            for (int i = 0; i < dialog.size(); ++i) {
                outFS.print(dialog.get(i) + "\n");
            }
        }

        finally {
            // Done with file, so try to close it
            if (outFS != null) {
                outFS.close();
            }

        }

    }
}
